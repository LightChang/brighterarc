name: Action Health Check
# Monitor daily-update workflow, analyze failures, and provide solutions

on:
  schedule:
    # Every 6 hours: 00:00, 06:00, 12:00, 18:00 UTC
    - cron: '0 0,6,12,18 * * *'
  workflow_dispatch:
    # Allow manual trigger for testing

permissions:
  contents: read
  issues: write
  actions: read

jobs:
  check-health:
    runs-on: ubuntu-latest
    env:
      TZ: Asia/Taipei

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check recent workflow runs
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ğŸ” æª¢æŸ¥ daily-update workflow ç‹€æ…‹..."

          # Get the most recent run of daily-update workflow
          RECENT_RUN=$(gh run list \
            --repo ${{ github.repository }} \
            --workflow "daily-update.yml" \
            --limit 1 \
            --json status,conclusion,createdAt,databaseId,headSha \
            2>/dev/null || echo "[]")

          if [[ "$RECENT_RUN" == "[]" ]] || [[ -z "$RECENT_RUN" ]]; then
            echo "âš ï¸ ç„¡æ³•å–å¾— workflow åŸ·è¡Œè¨˜éŒ„"
            echo "status=unknown" >> $GITHUB_OUTPUT
            exit 0
          fi

          STATUS=$(echo "$RECENT_RUN" | jq -r '.[0].status')
          CONCLUSION=$(echo "$RECENT_RUN" | jq -r '.[0].conclusion')
          CREATED_AT=$(echo "$RECENT_RUN" | jq -r '.[0].createdAt')
          RUN_ID=$(echo "$RECENT_RUN" | jq -r '.[0].databaseId')
          HEAD_SHA=$(echo "$RECENT_RUN" | jq -r '.[0].headSha')

          echo "æœ€è¿‘åŸ·è¡Œæ™‚é–“: $CREATED_AT"
          echo "ç‹€æ…‹: $STATUS"
          echo "çµæœ: $CONCLUSION"
          echo "Run ID: $RUN_ID"

          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          echo "created_at=$CREATED_AT" >> $GITHUB_OUTPUT
          echo "head_sha=$HEAD_SHA" >> $GITHUB_OUTPUT

          if [[ "$STATUS" == "completed" && "$CONCLUSION" == "failure" ]]; then
            echo "âŒ æœ€è¿‘çš„åŸ·è¡Œå¤±æ•—äº†ï¼"
            echo "status=failure" >> $GITHUB_OUTPUT
          elif [[ "$STATUS" == "completed" && "$CONCLUSION" == "success" ]]; then
            echo "âœ… æœ€è¿‘çš„åŸ·è¡ŒæˆåŠŸ"
            echo "status=success" >> $GITHUB_OUTPUT
          elif [[ "$STATUS" == "in_progress" ]] || [[ "$STATUS" == "queued" ]]; then
            echo "â³ æ­£åœ¨åŸ·è¡Œä¸­"
            echo "status=running" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ æœªçŸ¥ç‹€æ…‹: $STATUS / $CONCLUSION"
            echo "status=unknown" >> $GITHUB_OUTPUT
          fi

      - name: Check for stale runs
        id: stale
        run: |
          CREATED_AT="${{ steps.check.outputs.created_at }}"

          if [[ -z "$CREATED_AT" ]]; then
            echo "is_stale=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          CREATED_TS=$(date -d "$CREATED_AT" +%s 2>/dev/null || echo "0")
          NOW_TS=$(date +%s)
          DIFF_HOURS=$(( (NOW_TS - CREATED_TS) / 3600 ))

          echo "è·é›¢ä¸Šæ¬¡åŸ·è¡Œ: ${DIFF_HOURS} å°æ™‚"

          if [[ "$DIFF_HOURS" -gt 36 ]]; then
            echo "âš ï¸ è¶…é 36 å°æ™‚æœªåŸ·è¡Œï¼"
            echo "is_stale=true" >> $GITHUB_OUTPUT
            echo "hours_ago=$DIFF_HOURS" >> $GITHUB_OUTPUT
          else
            echo "is_stale=false" >> $GITHUB_OUTPUT
          fi

      - name: Analyze failure details
        id: analyze
        if: steps.check.outputs.status == 'failure'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RUN_ID="${{ steps.check.outputs.run_id }}"
          echo "ğŸ“Š åˆ†æå¤±æ•—åŸå› ..."

          # Get failed jobs and steps
          JOBS_JSON=$(gh api \
            "repos/${{ github.repository }}/actions/runs/${RUN_ID}/jobs" \
            --jq '.jobs[] | {name: .name, conclusion: .conclusion, steps: [.steps[] | {name: .name, conclusion: .conclusion, number: .number}]}' \
            2>/dev/null || echo "{}")

          # Find the failed step
          FAILED_JOB=""
          FAILED_STEP=""
          FAILED_STEP_NUM=""

          while IFS= read -r job; do
            JOB_NAME=$(echo "$job" | jq -r '.name')
            JOB_CONCLUSION=$(echo "$job" | jq -r '.conclusion')

            if [[ "$JOB_CONCLUSION" == "failure" ]]; then
              FAILED_JOB="$JOB_NAME"

              # Find failed step within job
              STEP_INFO=$(echo "$job" | jq -r '.steps[] | select(.conclusion == "failure") | "\(.number)|\(.name)"' | head -1)
              if [[ -n "$STEP_INFO" ]]; then
                FAILED_STEP_NUM=$(echo "$STEP_INFO" | cut -d'|' -f1)
                FAILED_STEP=$(echo "$STEP_INFO" | cut -d'|' -f2)
              fi
              break
            fi
          done <<< "$(gh api "repos/${{ github.repository }}/actions/runs/${RUN_ID}/jobs" --jq '.jobs[]' 2>/dev/null)"

          echo "å¤±æ•—çš„ Job: $FAILED_JOB"
          echo "å¤±æ•—çš„ Step: $FAILED_STEP"

          echo "failed_job=$FAILED_JOB" >> $GITHUB_OUTPUT
          echo "failed_step=$FAILED_STEP" >> $GITHUB_OUTPUT

          # Download and analyze logs
          echo "ğŸ“¥ ä¸‹è¼‰åŸ·è¡Œæ—¥èªŒ..."
          mkdir -p /tmp/logs
          gh run download "$RUN_ID" --repo ${{ github.repository }} --dir /tmp/logs 2>/dev/null || true

          # Also try to get logs via API
          gh run view "$RUN_ID" --repo ${{ github.repository }} --log 2>/dev/null > /tmp/run_log.txt || true

          # Extract error messages from logs
          ERROR_CONTEXT=""
          if [[ -f /tmp/run_log.txt ]]; then
            # Look for common error patterns
            ERROR_CONTEXT=$(grep -A 5 -B 2 -E "(error|Error|ERROR|failed|Failed|FAILED|exit code|âŒ)" /tmp/run_log.txt | tail -50 || true)
          fi

          # Save error context to file for later use
          echo "$ERROR_CONTEXT" > /tmp/error_context.txt

          # Determine error category and root cause
          ERROR_CATEGORY="unknown"
          ROOT_CAUSE=""
          SOLUTION=""

          case "$FAILED_STEP" in
            *"Fetch legislative data"*)
              ERROR_CATEGORY="data_fetch"
              if echo "$ERROR_CONTEXT" | grep -qi "timeout\|timed out"; then
                ROOT_CAUSE="ç«‹æ³•é™¢ API é€£ç·šè¶…æ™‚"
                SOLUTION="1. æª¢æŸ¥ç«‹æ³•é™¢ API ç‹€æ…‹: https://data.ly.gov.tw\n2. ç¨å¾Œé‡è©¦ï¼ˆå¯èƒ½æ˜¯æš«æ™‚æ€§å•é¡Œï¼‰\n3. å¦‚æŒçºŒç™¼ç”Ÿï¼Œè€ƒæ…®å¢åŠ è¶…æ™‚è¨­å®š"
              elif echo "$ERROR_CONTEXT" | grep -qi "openai\|embedding"; then
                ROOT_CAUSE="OpenAI API éŒ¯èª¤"
                SOLUTION="1. æª¢æŸ¥ OPENAI_API_KEY æ˜¯å¦æœ‰æ•ˆ\n2. ç¢ºèª API é¡åº¦æ˜¯å¦è¶³å¤ \n3. æª¢æŸ¥ OpenAI æœå‹™ç‹€æ…‹: https://status.openai.com"
              elif echo "$ERROR_CONTEXT" | grep -qi "rate limit"; then
                ROOT_CAUSE="API é€Ÿç‡é™åˆ¶"
                SOLUTION="1. ç­‰å¾…é€Ÿç‡é™åˆ¶é‡ç½®\n2. è€ƒæ…®é™ä½è«‹æ±‚é »ç‡\n3. å‡ç´š API æ–¹æ¡ˆ"
              else
                ROOT_CAUSE="è³‡æ–™æŠ“å–éç¨‹ä¸­ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤"
                SOLUTION="1. æª¢æŸ¥åŸ·è¡Œæ—¥èªŒäº†è§£è©³æƒ…\n2. æ‰‹å‹•åŸ·è¡Œ ./fetch_legislative_data.sh æ¸¬è©¦"
              fi
              ;;
            *"Update Qdrant"*)
              ERROR_CATEGORY="qdrant_upload"
              if echo "$ERROR_CONTEXT" | grep -qi "timeout\|connection"; then
                ROOT_CAUSE="Qdrant é€£ç·šå¤±æ•—"
                SOLUTION="1. æª¢æŸ¥ QDRANT_URL è¨­å®š\n2. ç¢ºèª Qdrant æœå‹™é‹ä½œä¸­\n3. æª¢æŸ¥ç¶²è·¯é€£ç·š"
              elif echo "$ERROR_CONTEXT" | grep -qi "401\|403\|unauthorized"; then
                ROOT_CAUSE="Qdrant èªè­‰å¤±æ•—"
                SOLUTION="1. æª¢æŸ¥ QDRANT_API_KEY æ˜¯å¦æ­£ç¢º\n2. ç¢ºèª API Key æœªéæœŸ\n3. æª¢æŸ¥ Qdrant Cloud æ§åˆ¶å°"
              elif echo "$ERROR_CONTEXT" | grep -qi "collection"; then
                ROOT_CAUSE="Qdrant collection å•é¡Œ"
                SOLUTION="1. ç¢ºèª legislative_replies collection å­˜åœ¨\n2. æª¢æŸ¥ collection è¨­å®šæ˜¯å¦æ­£ç¢º"
              else
                ROOT_CAUSE="Qdrant ä¸Šå‚³éç¨‹ç™¼ç”ŸéŒ¯èª¤"
                SOLUTION="1. æª¢æŸ¥ Qdrant æœå‹™ç‹€æ…‹\n2. ç¢ºèªè³‡æ–™æ ¼å¼æ­£ç¢º"
              fi
              ;;
            *"Verify Qdrant"*)
              ERROR_CATEGORY="qdrant_verify"
              ROOT_CAUSE="Qdrant é©—è­‰å¤±æ•—ï¼Œè³‡æ–™å¯èƒ½æœªæˆåŠŸå¯«å…¥"
              SOLUTION="1. æª¢æŸ¥ Qdrant é€£ç·šç‹€æ…‹\n2. ç¢ºèªä¸Šå‚³æ­¥é©Ÿæ˜¯å¦æˆåŠŸ\n3. æ‰‹å‹•æŸ¥è©¢ Qdrant ç¢ºèªè³‡æ–™"
              ;;
            *"Build monthly release"*)
              ERROR_CATEGORY="github_release"
              if echo "$ERROR_CONTEXT" | grep -qi "network\|timeout\|connection"; then
                ROOT_CAUSE="GitHub API é€£ç·šå•é¡Œ"
                SOLUTION="1. é€™é€šå¸¸æ˜¯æš«æ™‚æ€§å•é¡Œï¼Œé‡æ–°åŸ·è¡Œå³å¯\n2. æª¢æŸ¥ GitHub ç‹€æ…‹: https://githubstatus.com"
              elif echo "$ERROR_CONTEXT" | grep -qi "permission\|403"; then
                ROOT_CAUSE="GitHub æ¬Šé™ä¸è¶³"
                SOLUTION="1. ç¢ºèª GITHUB_TOKEN æœ‰ contents:write æ¬Šé™\n2. æª¢æŸ¥ repository è¨­å®š"
              else
                ROOT_CAUSE="GitHub Release å»ºç«‹/æ›´æ–°å¤±æ•—"
                SOLUTION="1. æª¢æŸ¥åŸ·è¡Œæ—¥èªŒäº†è§£è©³æƒ…\n2. æ‰‹å‹•åŸ·è¡Œ ./build_legislative_release.sh æ¸¬è©¦"
              fi
              ;;
            *"Commit daily data"*)
              ERROR_CATEGORY="git_commit"
              if echo "$ERROR_CONTEXT" | grep -qi "rejected\|fetch first"; then
                ROOT_CAUSE="Git push è¢«æ‹’çµ•ï¼Œé ç«¯æœ‰æ–°æäº¤"
                SOLUTION="1. é€™è¡¨ç¤ºæœ‰å…¶ä»–æäº¤ï¼Œéœ€è¦ rebase\n2. æ‰‹å‹•åŸ·è¡Œ: git pull --rebase origin main && git push"
              else
                ROOT_CAUSE="Git æäº¤éç¨‹ç™¼ç”ŸéŒ¯èª¤"
                SOLUTION="1. æª¢æŸ¥ Git è¨­å®š\n2. ç¢ºèªæœ‰æª”æ¡ˆéœ€è¦æäº¤"
              fi
              ;;
            *)
              ERROR_CATEGORY="unknown"
              ROOT_CAUSE="æœªçŸ¥éŒ¯èª¤ï¼Œéœ€è¦æª¢æŸ¥åŸ·è¡Œæ—¥èªŒ"
              SOLUTION="1. æŸ¥çœ‹å®Œæ•´åŸ·è¡Œæ—¥èªŒ\n2. åƒè€ƒ CLAUDE.md å•é¡Œæ’é™¤ç« ç¯€"
              ;;
          esac

          echo "error_category=$ERROR_CATEGORY" >> $GITHUB_OUTPUT
          echo "root_cause=$ROOT_CAUSE" >> $GITHUB_OUTPUT

          # Save solution to file (multiline)
          echo "$SOLUTION" > /tmp/solution.txt

          echo "ğŸ“‹ åˆ†æçµæœ:"
          echo "  éŒ¯èª¤é¡åˆ¥: $ERROR_CATEGORY"
          echo "  æ ¹æœ¬åŸå› : $ROOT_CAUSE"

      - name: Check existing issues
        id: existing
        if: steps.check.outputs.status == 'failure' || steps.stale.outputs.is_stale == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          EXISTING=$(gh issue list \
            --repo ${{ github.repository }} \
            --label "action-health" \
            --state open \
            --limit 1 \
            --json number \
            2>/dev/null || echo "[]")

          if [[ "$EXISTING" != "[]" ]] && [[ -n "$EXISTING" ]]; then
            ISSUE_NUM=$(echo "$EXISTING" | jq -r '.[0].number')
            echo "ğŸ“‹ å·²æœ‰é–‹å•Ÿçš„ Issue: #$ISSUE_NUM"
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "issue_number=$ISSUE_NUM" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Create detailed failure issue
        if: steps.check.outputs.status == 'failure' && steps.existing.outputs.exists != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RUN_ID="${{ steps.check.outputs.run_id }}"
          RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${RUN_ID}"
          CREATED_AT="${{ steps.check.outputs.created_at }}"
          FAILED_JOB="${{ steps.analyze.outputs.failed_job }}"
          FAILED_STEP="${{ steps.analyze.outputs.failed_step }}"
          ERROR_CATEGORY="${{ steps.analyze.outputs.error_category }}"
          ROOT_CAUSE="${{ steps.analyze.outputs.root_cause }}"

          # Read solution from file
          SOLUTION=$(cat /tmp/solution.txt 2>/dev/null || echo "è«‹æŸ¥çœ‹åŸ·è¡Œæ—¥èªŒ")

          # Read error context
          ERROR_CONTEXT=$(cat /tmp/error_context.txt 2>/dev/null | head -30 || echo "ç„¡æ³•å–å¾—éŒ¯èª¤å…§å®¹")

          # Determine labels based on category
          case "$ERROR_CATEGORY" in
            "data_fetch") EXTRA_LABEL=",api" ;;
            "qdrant_upload"|"qdrant_verify") EXTRA_LABEL=",qdrant" ;;
            "github_release"|"git_commit") EXTRA_LABEL=",github" ;;
            *) EXTRA_LABEL="" ;;
          esac

          BODY=$(cat <<EOF
          ## ğŸš¨ å•é¡Œæ‘˜è¦

          **Daily Update workflow åŸ·è¡Œå¤±æ•—**

          | é …ç›® | å…§å®¹ |
          |------|------|
          | åŸ·è¡Œæ™‚é–“ | ${CREATED_AT} |
          | å¤±æ•—ä½ç½® | ${FAILED_STEP:-æœªçŸ¥} |
          | éŒ¯èª¤é¡åˆ¥ | ${ERROR_CATEGORY} |

          ## ğŸ” æ ¹æœ¬åŸå› åˆ†æ

          **${ROOT_CAUSE}**

          ## ğŸ’¡ å»ºè­°è§£æ±ºæ–¹æ¡ˆ

          $(echo -e "$SOLUTION" | sed 's/^/> /')

          ## ğŸ“‹ éŒ¯èª¤æ—¥èªŒæ‘˜è¦

          \`\`\`
          ${ERROR_CONTEXT}
          \`\`\`

          ## ğŸ”— ç›¸é—œé€£çµ

          - [åŸ·è¡Œæ—¥èªŒ](${RUN_URL})
          - [å•é¡Œæ’é™¤æŒ‡å—](./CLAUDE.md#å¸¸è¦‹å•é¡Œæ’é™¤)

          ## âš¡ å¿«é€Ÿæ“ä½œ

          - [ ] ç¢ºèªå•é¡ŒåŸå› 
          - [ ] åŸ·è¡Œå»ºè­°è§£æ±ºæ–¹æ¡ˆ
          - [ ] æ‰‹å‹•è§¸ç™¼é‡æ–°åŸ·è¡Œï¼ˆå¦‚é©ç”¨ï¼‰
          - [ ] é—œé–‰æ­¤ Issue

          ---
          *æ­¤ Issue ç”± Action Health Check è‡ªå‹•å»ºç«‹*
          EOF
          )

          gh issue create \
            --repo ${{ github.repository }} \
            --title "ğŸš¨ [${ERROR_CATEGORY}] Daily Update å¤±æ•—: ${ROOT_CAUSE}" \
            --label "action-health,bug${EXTRA_LABEL}" \
            --body "$BODY"

          echo "âœ… å·²å»ºç«‹è©³ç´°åˆ†æ Issue"

      - name: Create stale issue
        if: steps.stale.outputs.is_stale == 'true' && steps.existing.outputs.exists != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          CREATED_AT="${{ steps.check.outputs.created_at }}"
          HOURS_AGO="${{ steps.stale.outputs.hours_ago }}"

          BODY=$(cat <<EOF
          ## âš ï¸ å•é¡Œæ‘˜è¦

          **Daily Update workflow è¶…é 36 å°æ™‚æœªåŸ·è¡Œ**

          | é …ç›® | å…§å®¹ |
          |------|------|
          | ä¸Šæ¬¡åŸ·è¡Œ | ${CREATED_AT} |
          | å·²éæ™‚é–“ | ${HOURS_AGO} å°æ™‚ |

          ## ğŸ” å¯èƒ½åŸå› 

          1. **GitHub Actions æ’ç¨‹å»¶é²** - GitHub æœ‰æ™‚æœƒå»¶é²åŸ·è¡Œæ’ç¨‹ä»»å‹™
          2. **Workflow è¢«åœç”¨** - æª¢æŸ¥ Actions é é¢ç¢ºèª workflow ç‹€æ…‹
          3. **Repository é–’ç½®** - GitHub æœƒåœç”¨é–’ç½® repo çš„æ’ç¨‹

          ## ğŸ’¡ å»ºè­°è§£æ±ºæ–¹æ¡ˆ

          ### ç«‹å³è¡Œå‹•
          1. å‰å¾€ [Actions é é¢](https://github.com/${{ github.repository }}/actions)
          2. é¸æ“‡ "Daily Legislative Data Update"
          3. é»æ“Š "Run workflow" æ‰‹å‹•è§¸ç™¼

          ### é•·æœŸé é˜²
          - ç¢ºä¿ repository ä¿æŒæ´»èº
          - å®šæœŸæª¢æŸ¥ workflow ç‹€æ…‹

          ## âš¡ å¿«é€Ÿæ“ä½œ

          - [ ] æ‰‹å‹•è§¸ç™¼ workflow
          - [ ] ç¢ºèª workflow æœªè¢«åœç”¨
          - [ ] é—œé–‰æ­¤ Issue

          ---
          *æ­¤ Issue ç”± Action Health Check è‡ªå‹•å»ºç«‹*
          EOF
          )

          gh issue create \
            --repo ${{ github.repository }} \
            --title "âš ï¸ Daily Update è¶…é ${HOURS_AGO} å°æ™‚æœªåŸ·è¡Œ" \
            --label "action-health" \
            --body "$BODY"

          echo "âœ… å·²å»ºç«‹ Issue"

      - name: Update existing issue with new analysis
        if: steps.check.outputs.status == 'failure' && steps.existing.outputs.exists == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM="${{ steps.existing.outputs.issue_number }}"
          RUN_ID="${{ steps.check.outputs.run_id }}"
          RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${RUN_ID}"
          FAILED_STEP="${{ steps.analyze.outputs.failed_step }}"
          ROOT_CAUSE="${{ steps.analyze.outputs.root_cause }}"
          CHECK_TIME=$(date '+%Y-%m-%d %H:%M:%S')

          SOLUTION=$(cat /tmp/solution.txt 2>/dev/null || echo "è«‹æŸ¥çœ‹åŸ·è¡Œæ—¥èªŒ")

          COMMENT=$(cat <<EOF
          ## ğŸ”„ å¥åº·æª¢æŸ¥æ›´æ–° - ${CHECK_TIME}

          **å•é¡Œä»æœªè§£æ±º**

          | é …ç›® | å…§å®¹ |
          |------|------|
          | æœ€æ–°åŸ·è¡Œ | [Run #${RUN_ID}](${RUN_URL}) |
          | å¤±æ•—ä½ç½® | ${FAILED_STEP:-æœªçŸ¥} |
          | æ ¹æœ¬åŸå›  | ${ROOT_CAUSE} |

          ### å»ºè­°è¡Œå‹•
          $(echo -e "$SOLUTION" | sed 's/^/> /')

          ---
          *ä¸‹æ¬¡æª¢æŸ¥å°‡åœ¨ 6 å°æ™‚å¾Œé€²è¡Œ*
          EOF
          )

          gh issue comment "$ISSUE_NUM" \
            --repo ${{ github.repository }} \
            --body "$COMMENT"

          echo "âœ… å·²æ›´æ–° Issue #$ISSUE_NUM"

      - name: Update existing stale issue
        if: steps.stale.outputs.is_stale == 'true' && steps.existing.outputs.exists == 'true' && steps.check.outputs.status != 'failure'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM="${{ steps.existing.outputs.issue_number }}"
          HOURS_AGO="${{ steps.stale.outputs.hours_ago }}"
          CHECK_TIME=$(date '+%Y-%m-%d %H:%M:%S')

          COMMENT=$(cat <<EOF
          ## ğŸ”„ å¥åº·æª¢æŸ¥æ›´æ–° - ${CHECK_TIME}

          Workflow ä»æœªåŸ·è¡Œï¼Œå·²é ${HOURS_AGO} å°æ™‚ã€‚

          è«‹æ‰‹å‹•è§¸ç™¼ workflow æˆ–æª¢æŸ¥æ˜¯å¦è¢«åœç”¨ã€‚
          EOF
          )

          gh issue comment "$ISSUE_NUM" \
            --repo ${{ github.repository }} \
            --body "$COMMENT"

          echo "âœ… å·²æ›´æ–° Issue #$ISSUE_NUM"

      - name: Summary
        run: |
          echo "========================================="
          echo "å¥åº·æª¢æŸ¥å®Œæˆ"
          echo "========================================="
          echo "æ™‚é–“: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "Workflow ç‹€æ…‹: ${{ steps.check.outputs.status }}"
          echo "æ˜¯å¦éæœŸ: ${{ steps.stale.outputs.is_stale }}"
          if [[ "${{ steps.check.outputs.status }}" == "failure" ]]; then
            echo "å¤±æ•—ä½ç½®: ${{ steps.analyze.outputs.failed_step }}"
            echo "éŒ¯èª¤é¡åˆ¥: ${{ steps.analyze.outputs.error_category }}"
            echo "æ ¹æœ¬åŸå› : ${{ steps.analyze.outputs.root_cause }}"
          fi
          echo "========================================="
